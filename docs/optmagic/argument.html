<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.2" />
<title>optmagic.argument API documentation</title>
<meta name="description" content="Written by Lucas Sinclair.
MIT Licensed.
Contact at www.sinclair.bio" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>optmagic.argument</code></h1>
</header>
<section id="section-intro">
<p>Written by Lucas Sinclair.
MIT Licensed.
Contact at www.sinclair.bio</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">#!/usr/bin/env python3
# -*- coding: utf-8 -*-

&#34;&#34;&#34;
Written by Lucas Sinclair.
MIT Licensed.
Contact at www.sinclair.bio
&#34;&#34;&#34;

# Built-in modules #
import inspect, functools, re

################################################################################
class Argument:

    def __init__(self, name, default, desc, optmagic):
        # The python variable name #
        self.name = name
        # The default value #
        self.default = default
        # The description of this argument in the docstring #
        self.desc = desc
        # A reference to the parent object #
        self.optmagic = optmagic
        # An attribute to check if a value is cached #
        self.letter_chosen = False

    def __repr__(self):
        &#34;&#34;&#34;A simple representation of this object to avoid memory addresses.&#34;&#34;&#34;
        return &#34;&lt;%s object &#39;%s&#39;&gt;&#34; % (self.__class__.__name__, self.name)

    def __str__(self):
        &#34;&#34;&#34;A longer string representation for printing purposes.&#34;&#34;&#34;
        msg = f&#34;Argument `{self.name}`&#34;
        if self.has_default: msg += f&#34; with default &#39;{self.default}&#39;.&#34;
        else:                msg += f&#34; without a default.&#34;
        return msg

    #----------------------------- Properties --------------------------------#
    @functools.cached_property
    def flat_desc(self):
        &#34;&#34;&#34;
        The same string as self.desc but with newlines and whitespaces removed
        as well as all lowercase.
        &#34;&#34;&#34;
        return &#39; &#39;.join(self.desc.split()).lower()

    @functools.cached_property
    def has_default(self):
        &#34;&#34;&#34;Did the argument have a default value or not?&#34;&#34;&#34;
        return self.default is not inspect._empty

    @functools.cached_property
    def short_letter(self):
        &#34;&#34;&#34;
        Pick a short letter for the option in addition to its full name.
        For this we need to check the short letters of the other arguments
        in order to avoid picking twice the same one.
        &#34;&#34;&#34;
        # Which letters have been taken already #
        existing = set(arg.short_letter for arg in self.optmagic.arguments
                       if arg.letter_chosen is True) | {&#39;h&#39;, &#39;v&#39;}
        # So that other arguments can check if this attribute is set #
        self.letter_chosen = True
        # Check if all letters are taken #
        if len(existing) == 26: return None
        # Function to pick possible letters iteratively #
        def pick_letter():
            parts = self.name.split(&#39;_&#39;)
            if parts[0] == &#39;output&#39;: yield &#39;o&#39;
            if len(parts) &gt; 1: yield parts[1][0]
            yield self.name[0]
            if len(parts) &gt; 2: yield parts[2][0]
            if len(parts) &gt; 3: yield parts[3][0]
            else:
                for letter in self.name:
                    if letter != &#39;_&#39;: yield letter
        # Pick #
        for letter in pick_letter():
            if letter not in existing: return letter

    #----------------------------- Parameters --------------------------------#
    @functools.cached_property
    def help(self):
        return self.desc + &#39;\n\n&#39;

    @functools.cached_property
    def choices(self):
        &#34;&#34;&#34;
        Example:
        parser.add_argument(&#39;throw&#39;, choices=[&#39;rock&#39;, &#39;paper&#39;, &#39;scissors&#39;]).
        &#34;&#34;&#34;
        # Initialize #
        choices = None
        # Detect cases where there are only two choices #
        regex = re.compile(&#34;either [&#39;\&#34;`](.+?)[&#39;\&#34;`] or [&#39;\&#34;`](.+?)[&#39;\&#34;`]&#34;)
        match = regex.findall(self.flat_desc)
        if match: choices = match[0]
        # Return #
        return choices

    @functools.cached_property
    def type(self):
        &#34;&#34;&#34;
        Example:
        parser.add_argument(&#39;throw&#39;,  type=int).
        &#34;&#34;&#34;
        return None

    @functools.cached_property
    def metavar(self):
        &#34;&#34;&#34;
        Example:
        parser.add_argument(&#39;throw&#39;,  metavar=&#34;EXAMPLE&#34;).
        &#34;&#34;&#34;
        # Initialize #
        metavar = None
        # Split the docstring into words #
        words = self.desc.split()
        # Let&#39;s take the second word of the docstring if the first word
        # is &#34;the&#34;.
        if words[0].lower() == &#34;the&#34;:
            metavar = words[1].upper()
        # Some names can be abbriviated #
        if metavar == &#34;NUMBER&#34;:    metavar = &#34;NUM&#34;
        if metavar == &#34;DIRECTORY&#34;: metavar = &#34;DIR&#34;
        # Return #
        return metavar

    @functools.cached_property
    def kwargs(self):
        # Initialize #
        kwargs = {}
        # Add options #
        if self.help is not None:    kwargs[&#39;help&#39;]    = self.help
        if self.default is not None: kwargs[&#39;default&#39;] = self.default
        if self.choices is not None: kwargs[&#39;choices&#39;] = self.choices
        if self.type is not None:    kwargs[&#39;type&#39;]    = self.type
        if self.metavar is not None: kwargs[&#39;metavar&#39;] = self.metavar
        # Is it required #
        kwargs[&#39;required&#39;] = not self.has_default
        # Return #
        return kwargs

    #------------------------------- Methods ---------------------------------#
    def add_arg(self, parser, required):
        &#34;&#34;&#34;Add this argument to the argparse parser.&#34;&#34;&#34;
        if self.has_default: group = parser
        else:                group = required
        return group.add_argument(&#39;--&#39; + self.name,
                                  &#39;-&#39; + self.short_letter,
                                  **self.kwargs)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="optmagic.argument.Argument"><code class="flex name class">
<span>class <span class="ident">Argument</span></span>
<span>(</span><span>name, default, desc, optmagic)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Argument:

    def __init__(self, name, default, desc, optmagic):
        # The python variable name #
        self.name = name
        # The default value #
        self.default = default
        # The description of this argument in the docstring #
        self.desc = desc
        # A reference to the parent object #
        self.optmagic = optmagic
        # An attribute to check if a value is cached #
        self.letter_chosen = False

    def __repr__(self):
        &#34;&#34;&#34;A simple representation of this object to avoid memory addresses.&#34;&#34;&#34;
        return &#34;&lt;%s object &#39;%s&#39;&gt;&#34; % (self.__class__.__name__, self.name)

    def __str__(self):
        &#34;&#34;&#34;A longer string representation for printing purposes.&#34;&#34;&#34;
        msg = f&#34;Argument `{self.name}`&#34;
        if self.has_default: msg += f&#34; with default &#39;{self.default}&#39;.&#34;
        else:                msg += f&#34; without a default.&#34;
        return msg

    #----------------------------- Properties --------------------------------#
    @functools.cached_property
    def flat_desc(self):
        &#34;&#34;&#34;
        The same string as self.desc but with newlines and whitespaces removed
        as well as all lowercase.
        &#34;&#34;&#34;
        return &#39; &#39;.join(self.desc.split()).lower()

    @functools.cached_property
    def has_default(self):
        &#34;&#34;&#34;Did the argument have a default value or not?&#34;&#34;&#34;
        return self.default is not inspect._empty

    @functools.cached_property
    def short_letter(self):
        &#34;&#34;&#34;
        Pick a short letter for the option in addition to its full name.
        For this we need to check the short letters of the other arguments
        in order to avoid picking twice the same one.
        &#34;&#34;&#34;
        # Which letters have been taken already #
        existing = set(arg.short_letter for arg in self.optmagic.arguments
                       if arg.letter_chosen is True) | {&#39;h&#39;, &#39;v&#39;}
        # So that other arguments can check if this attribute is set #
        self.letter_chosen = True
        # Check if all letters are taken #
        if len(existing) == 26: return None
        # Function to pick possible letters iteratively #
        def pick_letter():
            parts = self.name.split(&#39;_&#39;)
            if parts[0] == &#39;output&#39;: yield &#39;o&#39;
            if len(parts) &gt; 1: yield parts[1][0]
            yield self.name[0]
            if len(parts) &gt; 2: yield parts[2][0]
            if len(parts) &gt; 3: yield parts[3][0]
            else:
                for letter in self.name:
                    if letter != &#39;_&#39;: yield letter
        # Pick #
        for letter in pick_letter():
            if letter not in existing: return letter

    #----------------------------- Parameters --------------------------------#
    @functools.cached_property
    def help(self):
        return self.desc + &#39;\n\n&#39;

    @functools.cached_property
    def choices(self):
        &#34;&#34;&#34;
        Example:
        parser.add_argument(&#39;throw&#39;, choices=[&#39;rock&#39;, &#39;paper&#39;, &#39;scissors&#39;]).
        &#34;&#34;&#34;
        # Initialize #
        choices = None
        # Detect cases where there are only two choices #
        regex = re.compile(&#34;either [&#39;\&#34;`](.+?)[&#39;\&#34;`] or [&#39;\&#34;`](.+?)[&#39;\&#34;`]&#34;)
        match = regex.findall(self.flat_desc)
        if match: choices = match[0]
        # Return #
        return choices

    @functools.cached_property
    def type(self):
        &#34;&#34;&#34;
        Example:
        parser.add_argument(&#39;throw&#39;,  type=int).
        &#34;&#34;&#34;
        return None

    @functools.cached_property
    def metavar(self):
        &#34;&#34;&#34;
        Example:
        parser.add_argument(&#39;throw&#39;,  metavar=&#34;EXAMPLE&#34;).
        &#34;&#34;&#34;
        # Initialize #
        metavar = None
        # Split the docstring into words #
        words = self.desc.split()
        # Let&#39;s take the second word of the docstring if the first word
        # is &#34;the&#34;.
        if words[0].lower() == &#34;the&#34;:
            metavar = words[1].upper()
        # Some names can be abbriviated #
        if metavar == &#34;NUMBER&#34;:    metavar = &#34;NUM&#34;
        if metavar == &#34;DIRECTORY&#34;: metavar = &#34;DIR&#34;
        # Return #
        return metavar

    @functools.cached_property
    def kwargs(self):
        # Initialize #
        kwargs = {}
        # Add options #
        if self.help is not None:    kwargs[&#39;help&#39;]    = self.help
        if self.default is not None: kwargs[&#39;default&#39;] = self.default
        if self.choices is not None: kwargs[&#39;choices&#39;] = self.choices
        if self.type is not None:    kwargs[&#39;type&#39;]    = self.type
        if self.metavar is not None: kwargs[&#39;metavar&#39;] = self.metavar
        # Is it required #
        kwargs[&#39;required&#39;] = not self.has_default
        # Return #
        return kwargs

    #------------------------------- Methods ---------------------------------#
    def add_arg(self, parser, required):
        &#34;&#34;&#34;Add this argument to the argparse parser.&#34;&#34;&#34;
        if self.has_default: group = parser
        else:                group = required
        return group.add_argument(&#39;--&#39; + self.name,
                                  &#39;-&#39; + self.short_letter,
                                  **self.kwargs)</code></pre>
</details>
<h3>Instance variables</h3>
<dl>
<dt id="optmagic.argument.Argument.choices"><code class="name">var <span class="ident">choices</span></code></dt>
<dd>
<div class="desc"><p>Example:
parser.add_argument('throw', choices=['rock', 'paper', 'scissors']).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __get__(self, instance, owner=None):
    if instance is None:
        return self
    if self.attrname is None:
        raise TypeError(
            &#34;Cannot use cached_property instance without calling __set_name__ on it.&#34;)
    try:
        cache = instance.__dict__
    except AttributeError:  # not all objects have __dict__ (e.g. class defines slots)
        msg = (
            f&#34;No &#39;__dict__&#39; attribute on {type(instance).__name__!r} &#34;
            f&#34;instance to cache {self.attrname!r} property.&#34;
        )
        raise TypeError(msg) from None
    val = cache.get(self.attrname, _NOT_FOUND)
    if val is _NOT_FOUND:
        with self.lock:
            # check if another thread filled cache while we awaited lock
            val = cache.get(self.attrname, _NOT_FOUND)
            if val is _NOT_FOUND:
                val = self.func(instance)
                try:
                    cache[self.attrname] = val
                except TypeError:
                    msg = (
                        f&#34;The &#39;__dict__&#39; attribute on {type(instance).__name__!r} instance &#34;
                        f&#34;does not support item assignment for caching {self.attrname!r} property.&#34;
                    )
                    raise TypeError(msg) from None
    return val</code></pre>
</details>
</dd>
<dt id="optmagic.argument.Argument.flat_desc"><code class="name">var <span class="ident">flat_desc</span></code></dt>
<dd>
<div class="desc"><p>The same string as self.desc but with newlines and whitespaces removed
as well as all lowercase.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __get__(self, instance, owner=None):
    if instance is None:
        return self
    if self.attrname is None:
        raise TypeError(
            &#34;Cannot use cached_property instance without calling __set_name__ on it.&#34;)
    try:
        cache = instance.__dict__
    except AttributeError:  # not all objects have __dict__ (e.g. class defines slots)
        msg = (
            f&#34;No &#39;__dict__&#39; attribute on {type(instance).__name__!r} &#34;
            f&#34;instance to cache {self.attrname!r} property.&#34;
        )
        raise TypeError(msg) from None
    val = cache.get(self.attrname, _NOT_FOUND)
    if val is _NOT_FOUND:
        with self.lock:
            # check if another thread filled cache while we awaited lock
            val = cache.get(self.attrname, _NOT_FOUND)
            if val is _NOT_FOUND:
                val = self.func(instance)
                try:
                    cache[self.attrname] = val
                except TypeError:
                    msg = (
                        f&#34;The &#39;__dict__&#39; attribute on {type(instance).__name__!r} instance &#34;
                        f&#34;does not support item assignment for caching {self.attrname!r} property.&#34;
                    )
                    raise TypeError(msg) from None
    return val</code></pre>
</details>
</dd>
<dt id="optmagic.argument.Argument.has_default"><code class="name">var <span class="ident">has_default</span></code></dt>
<dd>
<div class="desc"><p>Did the argument have a default value or not?</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __get__(self, instance, owner=None):
    if instance is None:
        return self
    if self.attrname is None:
        raise TypeError(
            &#34;Cannot use cached_property instance without calling __set_name__ on it.&#34;)
    try:
        cache = instance.__dict__
    except AttributeError:  # not all objects have __dict__ (e.g. class defines slots)
        msg = (
            f&#34;No &#39;__dict__&#39; attribute on {type(instance).__name__!r} &#34;
            f&#34;instance to cache {self.attrname!r} property.&#34;
        )
        raise TypeError(msg) from None
    val = cache.get(self.attrname, _NOT_FOUND)
    if val is _NOT_FOUND:
        with self.lock:
            # check if another thread filled cache while we awaited lock
            val = cache.get(self.attrname, _NOT_FOUND)
            if val is _NOT_FOUND:
                val = self.func(instance)
                try:
                    cache[self.attrname] = val
                except TypeError:
                    msg = (
                        f&#34;The &#39;__dict__&#39; attribute on {type(instance).__name__!r} instance &#34;
                        f&#34;does not support item assignment for caching {self.attrname!r} property.&#34;
                    )
                    raise TypeError(msg) from None
    return val</code></pre>
</details>
</dd>
<dt id="optmagic.argument.Argument.help"><code class="name">var <span class="ident">help</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __get__(self, instance, owner=None):
    if instance is None:
        return self
    if self.attrname is None:
        raise TypeError(
            &#34;Cannot use cached_property instance without calling __set_name__ on it.&#34;)
    try:
        cache = instance.__dict__
    except AttributeError:  # not all objects have __dict__ (e.g. class defines slots)
        msg = (
            f&#34;No &#39;__dict__&#39; attribute on {type(instance).__name__!r} &#34;
            f&#34;instance to cache {self.attrname!r} property.&#34;
        )
        raise TypeError(msg) from None
    val = cache.get(self.attrname, _NOT_FOUND)
    if val is _NOT_FOUND:
        with self.lock:
            # check if another thread filled cache while we awaited lock
            val = cache.get(self.attrname, _NOT_FOUND)
            if val is _NOT_FOUND:
                val = self.func(instance)
                try:
                    cache[self.attrname] = val
                except TypeError:
                    msg = (
                        f&#34;The &#39;__dict__&#39; attribute on {type(instance).__name__!r} instance &#34;
                        f&#34;does not support item assignment for caching {self.attrname!r} property.&#34;
                    )
                    raise TypeError(msg) from None
    return val</code></pre>
</details>
</dd>
<dt id="optmagic.argument.Argument.kwargs"><code class="name">var <span class="ident">kwargs</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __get__(self, instance, owner=None):
    if instance is None:
        return self
    if self.attrname is None:
        raise TypeError(
            &#34;Cannot use cached_property instance without calling __set_name__ on it.&#34;)
    try:
        cache = instance.__dict__
    except AttributeError:  # not all objects have __dict__ (e.g. class defines slots)
        msg = (
            f&#34;No &#39;__dict__&#39; attribute on {type(instance).__name__!r} &#34;
            f&#34;instance to cache {self.attrname!r} property.&#34;
        )
        raise TypeError(msg) from None
    val = cache.get(self.attrname, _NOT_FOUND)
    if val is _NOT_FOUND:
        with self.lock:
            # check if another thread filled cache while we awaited lock
            val = cache.get(self.attrname, _NOT_FOUND)
            if val is _NOT_FOUND:
                val = self.func(instance)
                try:
                    cache[self.attrname] = val
                except TypeError:
                    msg = (
                        f&#34;The &#39;__dict__&#39; attribute on {type(instance).__name__!r} instance &#34;
                        f&#34;does not support item assignment for caching {self.attrname!r} property.&#34;
                    )
                    raise TypeError(msg) from None
    return val</code></pre>
</details>
</dd>
<dt id="optmagic.argument.Argument.metavar"><code class="name">var <span class="ident">metavar</span></code></dt>
<dd>
<div class="desc"><p>Example:
parser.add_argument('throw',
metavar="EXAMPLE").</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __get__(self, instance, owner=None):
    if instance is None:
        return self
    if self.attrname is None:
        raise TypeError(
            &#34;Cannot use cached_property instance without calling __set_name__ on it.&#34;)
    try:
        cache = instance.__dict__
    except AttributeError:  # not all objects have __dict__ (e.g. class defines slots)
        msg = (
            f&#34;No &#39;__dict__&#39; attribute on {type(instance).__name__!r} &#34;
            f&#34;instance to cache {self.attrname!r} property.&#34;
        )
        raise TypeError(msg) from None
    val = cache.get(self.attrname, _NOT_FOUND)
    if val is _NOT_FOUND:
        with self.lock:
            # check if another thread filled cache while we awaited lock
            val = cache.get(self.attrname, _NOT_FOUND)
            if val is _NOT_FOUND:
                val = self.func(instance)
                try:
                    cache[self.attrname] = val
                except TypeError:
                    msg = (
                        f&#34;The &#39;__dict__&#39; attribute on {type(instance).__name__!r} instance &#34;
                        f&#34;does not support item assignment for caching {self.attrname!r} property.&#34;
                    )
                    raise TypeError(msg) from None
    return val</code></pre>
</details>
</dd>
<dt id="optmagic.argument.Argument.short_letter"><code class="name">var <span class="ident">short_letter</span></code></dt>
<dd>
<div class="desc"><p>Pick a short letter for the option in addition to its full name.
For this we need to check the short letters of the other arguments
in order to avoid picking twice the same one.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __get__(self, instance, owner=None):
    if instance is None:
        return self
    if self.attrname is None:
        raise TypeError(
            &#34;Cannot use cached_property instance without calling __set_name__ on it.&#34;)
    try:
        cache = instance.__dict__
    except AttributeError:  # not all objects have __dict__ (e.g. class defines slots)
        msg = (
            f&#34;No &#39;__dict__&#39; attribute on {type(instance).__name__!r} &#34;
            f&#34;instance to cache {self.attrname!r} property.&#34;
        )
        raise TypeError(msg) from None
    val = cache.get(self.attrname, _NOT_FOUND)
    if val is _NOT_FOUND:
        with self.lock:
            # check if another thread filled cache while we awaited lock
            val = cache.get(self.attrname, _NOT_FOUND)
            if val is _NOT_FOUND:
                val = self.func(instance)
                try:
                    cache[self.attrname] = val
                except TypeError:
                    msg = (
                        f&#34;The &#39;__dict__&#39; attribute on {type(instance).__name__!r} instance &#34;
                        f&#34;does not support item assignment for caching {self.attrname!r} property.&#34;
                    )
                    raise TypeError(msg) from None
    return val</code></pre>
</details>
</dd>
<dt id="optmagic.argument.Argument.type"><code class="name">var <span class="ident">type</span></code></dt>
<dd>
<div class="desc"><p>Example:
parser.add_argument('throw',
type=int).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __get__(self, instance, owner=None):
    if instance is None:
        return self
    if self.attrname is None:
        raise TypeError(
            &#34;Cannot use cached_property instance without calling __set_name__ on it.&#34;)
    try:
        cache = instance.__dict__
    except AttributeError:  # not all objects have __dict__ (e.g. class defines slots)
        msg = (
            f&#34;No &#39;__dict__&#39; attribute on {type(instance).__name__!r} &#34;
            f&#34;instance to cache {self.attrname!r} property.&#34;
        )
        raise TypeError(msg) from None
    val = cache.get(self.attrname, _NOT_FOUND)
    if val is _NOT_FOUND:
        with self.lock:
            # check if another thread filled cache while we awaited lock
            val = cache.get(self.attrname, _NOT_FOUND)
            if val is _NOT_FOUND:
                val = self.func(instance)
                try:
                    cache[self.attrname] = val
                except TypeError:
                    msg = (
                        f&#34;The &#39;__dict__&#39; attribute on {type(instance).__name__!r} instance &#34;
                        f&#34;does not support item assignment for caching {self.attrname!r} property.&#34;
                    )
                    raise TypeError(msg) from None
    return val</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="optmagic.argument.Argument.add_arg"><code class="name flex">
<span>def <span class="ident">add_arg</span></span>(<span>self, parser, required)</span>
</code></dt>
<dd>
<div class="desc"><p>Add this argument to the argparse parser.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_arg(self, parser, required):
    &#34;&#34;&#34;Add this argument to the argparse parser.&#34;&#34;&#34;
    if self.has_default: group = parser
    else:                group = required
    return group.add_argument(&#39;--&#39; + self.name,
                              &#39;-&#39; + self.short_letter,
                              **self.kwargs)</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="optmagic" href="index.html">optmagic</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="optmagic.argument.Argument" href="#optmagic.argument.Argument">Argument</a></code></h4>
<ul class="two-column">
<li><code><a title="optmagic.argument.Argument.add_arg" href="#optmagic.argument.Argument.add_arg">add_arg</a></code></li>
<li><code><a title="optmagic.argument.Argument.choices" href="#optmagic.argument.Argument.choices">choices</a></code></li>
<li><code><a title="optmagic.argument.Argument.flat_desc" href="#optmagic.argument.Argument.flat_desc">flat_desc</a></code></li>
<li><code><a title="optmagic.argument.Argument.has_default" href="#optmagic.argument.Argument.has_default">has_default</a></code></li>
<li><code><a title="optmagic.argument.Argument.help" href="#optmagic.argument.Argument.help">help</a></code></li>
<li><code><a title="optmagic.argument.Argument.kwargs" href="#optmagic.argument.Argument.kwargs">kwargs</a></code></li>
<li><code><a title="optmagic.argument.Argument.metavar" href="#optmagic.argument.Argument.metavar">metavar</a></code></li>
<li><code><a title="optmagic.argument.Argument.short_letter" href="#optmagic.argument.Argument.short_letter">short_letter</a></code></li>
<li><code><a title="optmagic.argument.Argument.type" href="#optmagic.argument.Argument.type">type</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.2</a>.</p>
</footer>
</body>
</html>